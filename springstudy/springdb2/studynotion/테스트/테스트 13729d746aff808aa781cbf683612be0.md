# 테스트

- 데이터베이스 연동
- 데이터베이스 분리
- 데이터 롤백
- @Transactional
- 임베디드 모드 DB
- 스프링 부트와 임베디드 모드

## 테스트 - 데이터베이스 연동

**test → application.properties**

```java
spring.profiles.active=test

spring.datasource.url=jdbc:h2:tcp://localhost/~/test
spring.datasource.username=sa

#jdbcTemplate sql log
logging.level.org.springframework.jdbc=debug

```

→ 테스트 코드를 돌려보면, 에러가 발생한다.

왜? 이미 데이터베이스에 데이터가 있어서 예측한 결과와 다르기 때문이다.

따라서 테스트 코드, 테스트를 돌리는 환경은 별도로 구축해야 한다.

- H2 DB →
    - /test : 서버 전용 DB
    - /testcase : test 케이스 전용 DB

**데이터베이스 파일 생성**

- JDBC URL에 다음 입력,
- `jdbc:h2:~/testcase` (최초 한번)
- `~/testcase.mv.db` 파일 생성 확인
- 이후부터는 `jdbc:h2:tcp://localhost/~/testcase` 이렇게 접속

### 테이블 생성하기

**testcase 데이터베이스에도 item 테이블을 생성하자**

```java
drop table if exists item CASCADE;
create table item
(
id bigint generated by default as identity,
item_name varchar(10),
price integer,
quantity integer,
primary key (id)
);
```

**test → application.properties**

```java
spring.profiles.active=test

spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase
spring.datasource.username=sa

#jdbcTemplate sql log
logging.level.org.springframework.jdbc=debug
```

**다시 테스트를 실행해보자**

- findItems() 테스트만 먼저 단독으로 실행하면 성공한다.
- 그러나 이후 반복하거나, 위의 SAVE 등의 테스트를 진행하면 다시 실패한다
- 이미 데이터를 추가했기 때문에 실패! → 결과적으로 테스트 데이터가 오염된 것이다.

테스트에서 매우 중요한 원칙은 다음과 같다.

- **테스트는 다른 테스트와 격리해야 한다**
- **테스트는 반복해서 실행할 수 있어야 한다**

## 테스트 - 데이터 롤백

**트랜잭션과 롤백 전략**

테스트가 끝나고 강제로 롤백해버리면, 데이터가 깔끔하게 제거된다.

테스트 전 후 마다 트랜잭션 시작과 트랜잭션 롤백을 해주자!

→ “`@BeforeEach`” , “`@AfterEach`” 기능을 사용하자.

```java
@Autowired
PlatformTransactionManager transactionManager;
TransactionStatus status;

@BeforeEach
void beforeEach() {
    status = transactionManager.getTransaction(new DefaultTransactionDefinition());
}

@AfterEach
void afterEach() {
    if (itemRepository instanceof MemoryItemRepository) {
        ((MemoryItemRepository) itemRepository).clearStore();
    }
    //트랜잭션 롤백
    transactionManager.rollback(status);
}
```

## **테스트** - @Transactional

스프링은 테스트 데이터 초기화를 위해 트랜잭션을 적용하고 롤백하는 방식을 `@Transactional` 애노테이션 하나로 깔끔하게 해결해준다.

- 이전에 테스트에 트랜잭션과 롤백을 위해 추가했던 코드들을 주석 처리하자.

```java
@Transactional
@SpringBootTest
class ItemRepositoryTest {

    @Autowired
    ItemRepository itemRepository;

//    @Autowired
//    PlatformTransactionManager transactionManager;
//    TransactionStatus status;
//
//    @BeforeEach
//    void beforeEach() {
//        status = transactionManager.getTransaction(new DefaultTransactionDefinition());
//    }

    @AfterEach
    void afterEach() {
        if (itemRepository instanceof MemoryItemRepository) {
            ((MemoryItemRepository) itemRepository).clearStore();
        }
        //트랜잭션 롤백
//        transactionManager.rollback(status);
    }
```

`ItemRepositoryTest` 테스트 코드에 스프링이 제공하는 `@Transactional` 를 추가하자.

**테스트 결과 성공!**

### @Transactional 원리

원래 스프링이 제공하는 `@Transactional` 애노테이션 로직이 성공하면 커밋하도록 동작한다.

**그러나 테스트에서 사용하면 특별하게 동작한다.**

`@Transactional` 이 테스트에 있으면, 스프링은 테스트를 트랜잭션 안에서 실행하고, **테스트가 끝나면** 트랜잭션을 자동으로 **롤백 한다.**

**@Transactional 이 적용된 테스트 동작 방식**

![image.png](%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3%2013729d746aff808aa781cbf683612be0/image.png)

테스트 케이스의 메서드나 클래스에 `@Transactional` 을 직접 붙여서 사용할 때 만 이렇게 동작한다.

**정리**

- 테스트가 끝난 후 개발자가 직접 데이터를 삭제하지 않아도 되는 편리함을 제공한다.
- 테스트 실행 중에 데이터를 등록하고 중간에 테스트가 강제로 종료되어도 걱정이 없다. 트랜잭션을 커밋하지 않기 때문에, 데이터는 자동으로 롤백된다.
- 트랜잭션 범위 안에서 테스트를 진행하기 때문에 동시에 다른 테스트가 진행되어도 서로 영향을 주지 않는 장점이 있다.
- @Transactional 덕분에 아주 편리하게 다음 원칙을 지킬 수 있게 되었다.
    - 테스트는 다른 테스트와 격리해야 한다.
    - 테스트는 반복해서 실행할 수 있어야 한다.

**강제로 커밋하기 - @Commit**

테스트에서 커밋을 해서 데이터베이스에 데이터가 잘 보관되었는지 최종 결과를 눈으로 확인하고 싶을 때도 있다.

이럴 때는 `@Commit` 을 **클래스 또는 메서드에 붙이면 테스트 종료 후 롤백 대신 커밋이 호출된다.** 

## 테스트 - 임베디드 모드 DB

테스트 케이스를 실행하기 위해서 별도의 데이터베이스를 설치하고, 운영하는 것은 상당히 번잡한 작업이다.

테스트를 검증할 용도로 사용되기 때문에 테스트가 끝나면 데이터베이스의 데이터를 모두 삭제해도 된다.

**임베디드 모드**

H2 데이터베이스는 자바로 개발되어 있고, JVM 안에서 메모리 모드로 동작하는 특별한 기능을 제공한다.

애플리케이션을 실행할 때 H2 데이터베이스도 해당 JVM 메모리에 함께 실행할 수 있다.

**DB를 애플리케이션에 내장해서 함께 실행한다고 해서 임베디드 모드라 한다.**

물론 **애플리케이션이 종료되면** 임베디드 모드로 동작하는 **H2 데이터베이스도 함께 종료되고, 데이터도 모두 사라진다.**

### 임베디드 모드 직접 사용

임베디드 모드를 직접 사용하는 방법은 다음과 같다.

**ItemServiceApplication**

```java
@Bean
	@Profile("test")
	public DataSource dataSource() {
		log.info("memory database 초기화");
		DriverManagerDataSource dataSource = new DriverManagerDataSource();
		dataSource.setDriverClassName("org.h2.Driver");
		dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
		dataSource.setUsername("sa");
		dataSource.setPassword("");
		return dataSource;
	}
```

→ 테스트코드의 설정을 “test” 라고 설정하였다.

해당 코드는 테스트가 실행 될 때 데이터베이스 를 메모리의 h2 로 사용한다는 뜻.

**하지만 바로 실행한다면 다음의 에러가 발생한다.**

```java
Caused by: org.h2.jdbc.JdbcSQLSyntaxErrorException: Table "ITEM" not found; SQL statement:
```

**왜? 현재 메모리의 H2 DB 에는 테이블이 없기 때문이다.**

따라서 스프링 부트 - 기본 SQL 스크립트를 사용해서 데이터베이스를 초기화하는 기능을 제공한다.

**스프링부트 - 기본 SQL 스크립트를 초기 시점에 실행하여 데이터베이스를 초기화**

package 구조

**→ src/test/resources/schema.sql**

```java
drop table if exists item CASCADE;
create table item
(
id bigint generated by default as identity,
item_name varchar(10),
price integer,
quantity integer,
primary key (id)
);
```

**이후 테스트 코드를 다시 실행해 보자 → 성공**

## 테스트 - 스프링 부트 와 임베디드 모드

위의 임베디드모드에 대한 데이터베이스 설정도 기본으로 제공한다.

**스프링부트는 데이터베이스에 대한 별다른 설정이 없다면? → 임베디드 데이터베이스를 사용한다.**

따라서, 

1. 기존의 테스트코드에 있는 데이터베이스 설정 관련 코드를 주석처리 한다.
2. Application 의 설정을 없앤다.

```java
package hello.itemservice;

import hello.itemservice.config.*;
import hello.itemservice.repository.ItemRepository;
import hello.itemservice.service.ItemService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Import;
import org.springframework.context.annotation.Profile;
import org.springframework.jdbc.datasource.DriverManagerDataSource;

import javax.sql.DataSource;

@Slf4j
//@Import(MemoryConfig.class)
//@Import(JdbcTemplateV1Config.class)
//@Import(JdbcTemplateV2Config.class)
@Import(JdbcTemplateV3Config.class)
@SpringBootApplication(scanBasePackages = "hello.itemservice.web")
public class ItemServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(ItemServiceApplication.class, args);
	}

	@Bean
	@Profile("local")
	public TestDataInit testDataInit(ItemRepository itemRepository) {
		return new TestDataInit(itemRepository);
	}

//	@Bean
//	@Profile("test")
//	public DataSource dataSource() {
//		log.info("memory database 초기화");
//		DriverManagerDataSource dataSource = new DriverManagerDataSource();
//		dataSource.setDriverClassName("org.h2.Driver");
//		dataSource.setUrl("jdbc:h2:mem:db;DB_CLOSE_DELAY=-1");
//		dataSource.setUsername("sa");
//		dataSource.setPassword("");
//		return dataSource;
//	}
}

```

**Test - application.properties**

```java
spring.profiles.active=test

#spring.datasource.url=jdbc:h2:tcp://localhost/~/testcase
#spring.datasource.username=sa
#
##jdbcTemplate sql log
logging.level.org.springframework.jdbc=debug
```

**실행 결과 - 성공!**

데이터베이스 이름은 스프링이 랜덤 한 값으로 자동 설정하여 동작시킨다 → 충돌 방지.